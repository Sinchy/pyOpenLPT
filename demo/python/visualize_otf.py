
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import os
import sys

def load_otf(filepath):
    """
    Parses the OTF.txt file generated by STB VSC module.
    Format:
    # Size...
    n_cam, nx, ny, nz, n_grid
    # Boundary...
    xmin, xmax, ymin, ymax, zmin, zmax
    # a...
    Matrix (n_cam rows, n_grid cols)
    # b...
    # c...
    # alpha...
    """
    if not os.path.exists(filepath):
        print(f"Error: File not found: {filepath}")
        return None

    with open(filepath, 'r') as f:
        lines = f.readlines()

    header_size = lines[1].strip().split(',')
    n_cam = int(header_size[0])
    nx = int(header_size[1])
    ny = int(header_size[2])
    nz = int(header_size[3])
    n_grid = int(header_size[4])

    header_bound = lines[3].strip().split(',')
    xmin = float(header_bound[0])
    xmax = float(header_bound[1])
    ymin = float(header_bound[2])
    ymax = float(header_bound[3])
    zmin = float(header_bound[4])
    zmax = float(header_bound[5])

    print(f"OTF Loaded: {n_cam} cameras, Grid ({nx}x{ny}x{nz})={n_grid}")
    print(f"Bounds: X[{xmin},{xmax}] Y[{ymin},{ymax}] Z[{zmin},{zmax}]")

    # Helper to parse matrix block
    def parse_matrix(start_line, rows, cols):
        mat = np.zeros((rows, cols))
        current_line = start_line
        for r in range(rows):
            # Read line, split by comma, remove empty
            vals = [float(x) for x in lines[current_line].strip().split(',') if x]
            # Handle potential trailing comma
            if len(vals) != cols:
                 # Standard Matrix::write output (comma separated)
                 # might have trailing comma logic or newline
                 pass
            mat[r, :] = vals[:cols]
            current_line += 1
        return mat, current_line

    # Find start lines by searching for comments strings
    # But since file structure is fixed order...
    # Line 0: # Size
    # Line 1: Data
    # Line 2: # Boundary
    # Line 3: Data
    # Line 4: # a
    # Line 5...: Data (n_cam lines)
    # Then # b
    # Then # c
    # Then # alpha

    curr = 5 # Start of 'a' data
    a_mat, curr = parse_matrix(curr, n_cam, n_grid)
    
    # Next line is # b
    curr += 1 # Skip comment
    b_mat, curr = parse_matrix(curr, n_cam, n_grid)

    curr += 1 # Skip comment
    c_mat, curr = parse_matrix(curr, n_cam, n_grid)

    curr += 1 # Skip comment
    alpha_mat, curr = parse_matrix(curr, n_cam, n_grid)

    return {
        'n_cam': n_cam, 'nx': nx, 'ny': ny, 'nz': nz,
        'bounds': (xmin, xmax, ymin, ymax, zmin, zmax),
        'a': a_mat, 'b': b_mat, 'c': c_mat, 'alpha': alpha_mat
    }

def visualize_otf(data, cam_id=0):
    nx, ny, nz = data['nx'], data['ny'], data['nz']
    xmin, xmax, ymin, ymax, zmin, zmax = data['bounds']
    
    print(f"Visualizing Camera {cam_id}...")
    
    if cam_id >= data['n_cam']:
        print(f"Error: Camera ID {cam_id} out of range (0-{data['n_cam']-1})")
        return

    # Generate Grid Coordinates
    dx = (xmax - xmin) / (nx - 1) if nx > 1 else 0
    dy = (ymax - ymin) / (ny - 1) if ny > 1 else 0
    dz = (zmax - zmin) / (nz - 1) if nz > 1 else 0

    X, Y, Z = np.zeros(nx*ny*nz), np.zeros(nx*ny*nz), np.zeros(nx*ny*nz)
    
    idx = 0
    for i in range(nx):
        for j in range(ny):
            for k in range(nz):
                X[idx] = xmin + i * dx
                Y[idx] = ymin + j * dy
                Z[idx] = zmin + k * dz
                idx += 1
    
    # Visualize Camera 'a' parameter (Peak Intensity)
    a_vals = data['a'][cam_id, :]

    # Reshape a_vals to 3D grid for interpolation
    a_grid = a_vals.reshape((nx, ny, nz))
    
    # Check if interpolation is requested/needed (if grid is small)
    use_interpolation = True
    if use_interpolation:
        try:
            from scipy.interpolate import RegularGridInterpolator
            
            # Create original grid axes
            x_ax = np.linspace(xmin, xmax, nx) if nx > 1 else np.array([xmin])
            y_ax = np.linspace(ymin, ymax, ny) if ny > 1 else np.array([ymin])
            z_ax = np.linspace(zmin, zmax, nz) if nz > 1 else np.array([zmin])
            
            # Handle singleton dimensions if any (though usually nx,ny,nz > 1)
            # RegularGridInterpolator requires strictly increasing points
            
            if nx > 1 and ny > 1 and nz > 1:
                interp = RegularGridInterpolator((x_ax, y_ax, z_ax), a_grid, bounds_error=False, fill_value=None)
                
                # Create denser grid
                factor = 10 
                dnx, dny, dnz = nx * factor, ny * factor, nz * factor
                
                # Limit max points to avoid memory issues/lag
                if dnx*dny*dnz > 1000000:
                    factor = int((1000000)**(1/3) / max(nx, ny, nz))
                    dnx, dny, dnz = nx * factor, ny * factor, nz * factor
                
                dx_new = np.linspace(xmin, xmax, dnx)
                dy_new = np.linspace(ymin, ymax, dny)
                dz_new = np.linspace(zmin, zmax, dnz)
                
                DX, DY, DZ = np.meshgrid(dx_new, dy_new, dz_new, indexing='ij')
                pts_new = np.array([DX.flatten(), DY.flatten(), DZ.flatten()]).T
                
                a_vals_new = interp(pts_new)
                
                # Update data for plotting
                X, Y, Z = pts_new[:, 0], pts_new[:, 1], pts_new[:, 2]
                a_vals = a_vals_new
                print(f"Interpolated grid to {dnx}x{dny}x{dnz} = {len(X)} points")
                
        except ImportError:
            print("Scipy not installed, showing original sparse grid.")
    
    # ... interpolation logic above remains ...
    
    # Check backend preference
    backend = 'qt' 
    
    if backend == 'qt':
        try:
            from PySide6.QtWidgets import QApplication, QMainWindow, QVBoxLayout, QWidget
            from PySide6.QtCore import Qt
            import pyqtgraph.opengl as gl
            
            print("PySide6 and pyqtgraph found. Attempting to launch interactive viewer...")
            
            class OTFViewer(QMainWindow):
                def __init__(self, X, Y, Z, vals, cam_id):
                    super().__init__()
                    self.setWindowTitle(f"OTF Viewer - Camera {cam_id}")
                    self.resize(1000, 800)
                    
                    self.central_widget = QWidget()
                    self.setCentralWidget(self.central_widget)
                    self.layout = QVBoxLayout(self.central_widget)
                    
                    self.view = gl.GLViewWidget()
                    self.view.opts['distance'] = 100
                    self.layout.addWidget(self.view)
                    
                    g = gl.GLGridItem()
                    g.scale(10, 10, 10)
                    self.view.addItem(g)
                    
                    pos = np.stack([X, Y, Z], axis=1)
                    norm_vals = (vals - np.min(vals)) / (np.max(vals) - np.min(vals) + 1e-9)
                    
                    colors = np.zeros((len(vals), 4))
                    colors[:, 0] = norm_vals
                    colors[:, 1] = norm_vals
                    colors[:, 2] = 1 - norm_vals
                    
                    if len(pos) > 10000: 
                        colors[:, 3] = 0.05 
                        size = 5
                    else:
                        colors[:, 3] = 0.8
                        size = 10
                        
                    sp = gl.GLScatterPlotItem(pos=pos, color=colors, size=size, pxMode=True)
                    self.view.addItem(sp)
                    
            app = QApplication.instance()
            if not app:
                print("Creating new QApplication...")
                app = QApplication(sys.argv)
            else:
                print("Using existing QApplication...")

            viewer = OTFViewer(X, Y, Z, a_vals, cam_id)
            viewer.show()
            
            # Critical for notebooks: keep the window open!
            # If using %gui qt, app.exec() is not needed.
            # But plain %matplotlib inline doesn't start qt event loop.
            if not hasattr(sys, 'ps1'): 
                print("Running app.exec()...")
                app.exec()
            else:
                 print("Interactive mode detected. If window doesn't appear, try execution via terminal or use %gui qt in notebook.")
                 # Forcing exec for user since they said "no popup"
                 # Warning: This might block the kernel until window is closed
                 print("Forcing app.exec() to ensure window shows (this blocks kernel)...")
                 app.exec()

            return 
            
        except ImportError as e:
            print(f"Pyqtgraph not found ({e}), falling back to Matplotlib embedded in PySide6.")
            
            try:
                from PySide6.QtWidgets import QApplication, QMainWindow, QVBoxLayout, QWidget
                from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg as FigureCanvas
                from matplotlib.backends.backend_qtagg import NavigationToolbar2QT as NavigationToolbar
                from matplotlib.figure import Figure
                
                print("Launching Matplotlib via PySide6...")

                class MatplotlibViewer(QMainWindow):
                    def __init__(self, X, Y, Z, vals, cam_id):
                        super().__init__()
                        self.setWindowTitle(f"OTF Viewer (Matplotlib) - Camera {cam_id}")
                        self.resize(1000, 800)
                        
                        self.central_widget = QWidget()
                        self.setCentralWidget(self.central_widget)
                        self.layout = QVBoxLayout(self.central_widget)
                        
                        # Create Matplotlib Figure
                        self.fig = Figure(figsize=(10, 8))
                        self.canvas = FigureCanvas(self.fig)
                        self.layout.addWidget(self.canvas)
                        
                        # Add Toolbar
                        self.toolbar = NavigationToolbar(self.canvas, self)
                        self.layout.addWidget(self.toolbar)
                        
                        # Plot
                        self.ax = self.fig.add_subplot(111, projection='3d')
                        
                        if len(X) > 10000: # interpolated
                            s_val = 5 
                            alpha_val = 0.2 
                        else:
                            s_val = 50
                            alpha_val = 1.0

                        img = self.ax.scatter(X, Y, Z, c=vals, cmap='viridis', marker='o', s=s_val, alpha=alpha_val)
                        self.fig.colorbar(img, ax=self.ax, label=f'OTF Peak Intensity a (Cam {cam_id})')
                        
                        self.ax.set_xlabel('X (mm)')
                        self.ax.set_ylabel('Y (mm)')
                        self.ax.set_zlabel('Z (mm)')
                        self.ax.set_title(f'OTF Light Field: Camera {cam_id} - Parameter a')
                        
                        # Stats
                        print(f"\nStats for Camera {cam_id} 'a':")
                        print(f"  Min: {np.min(vals):.4f}")
                        print(f"  Max: {np.max(vals):.4f}")
                        print(f"  Mean: {np.mean(vals):.4f}")

                app = QApplication.instance()
                if not app:
                    app = QApplication(sys.argv)
                
                viewer = MatplotlibViewer(X, Y, Z, a_vals, cam_id)
                viewer.show()
                
                if not hasattr(sys, 'ps1'): 
                    app.exec()
                else:
                    print("Interactive mode: Forcing app execution...")
                    app.exec()
                    
                return

            except ImportError as e2:
                 print(f"Critical: PySide6 Matplotlib backend missing ({e2}). Using standard inline plot.")
                 # Fall through to raw matplotlib

    # --- Standard Matplotlib Fallback (Inline/Static) ---
    fig = plt.figure(figsize=(10, 8))
    ax = fig.add_subplot(111, projection='3d')
    
    if use_interpolation:
        s_val = 5 
        alpha_val = 0.2 
    else:
        s_val = 50
        alpha_val = 1.0

    img = ax.scatter(X, Y, Z, c=a_vals, cmap='viridis', marker='o', s=s_val, alpha=alpha_val)
    fig.colorbar(img, ax=ax, label=f'OTF Peak Intensity a (Cam {cam_id})')
    
    ax.set_xlabel('X (mm)')
    ax.set_ylabel('Y (mm)')
    ax.set_zlabel('Z (mm)')
    ax.set_title(f'OTF Light Field: Camera {cam_id} - Parameter a')
    
    # Show stats
    print(f"\nStats for Camera {cam_id} 'a':")
    print(f"  Min: {np.min(a_vals):.4f}")
    print(f"  Max: {np.max(a_vals):.4f}")
    print(f"  Mean: {np.mean(a_vals):.4f}")
    
    plt.show()

if __name__ == "__main__":
    # Default path relative to this script in demo/python/
    # Need to point to test/results/test_STB/OTF.txt
    default_path = os.path.join(os.path.dirname(__file__), "../../test/results/test_STB/OTF.txt")
    print(f"Looking for: {default_path}")
    
    data = load_otf(default_path)
    if data:
        visualize_otf(data)
